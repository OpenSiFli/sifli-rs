//! Audio subsystem driver for SF32LB52x
//!
//! Supports AUDPRC (digital audio processor) + AUDCODEC (analog codec) for
//! DAC output through the internal Class-D PA.
//!
//! # Architecture
//!
//! ```text
//! DMA → AUDPRC TX_CH0 FIFO → DAC Path (mixer/vol) → AUDCODEC DAC → Class-D PA
//! ```
//!
//! AUDPRC and AUDCODEC are connected via internal bus (`op_mode=0`), no external pins needed.
//!
//! # Example (blocking)
//!
//! ```ignore
//! let mut dac = audio::AudioDac::new_blocking(
//!     p.AUDPRC,
//!     p.DMAC1_CH1,
//!     audio::DacConfig::default(),
//! );
//! // One-shot playback
//! dac.write_blocking(&samples);
//! ```
//!
//! # Example (async, streaming)
//!
//! ```ignore
//! bind_interrupts!(struct Irqs {
//!     AUDPRC => audio::InterruptHandler;
//! });
//!
//! let mut dac = audio::AudioDac::new(
//!     p.AUDPRC,
//!     p.DMAC1_CH1,
//!     Irqs,
//!     audio::DacConfig::default(),
//! );
//!
//! // One-shot write
//! dac.write(&samples).await;
//!
//! // Or: continuous streaming with ring buffer
//! let mut stream = dac.start_stream(&mut dma_buf);
//! loop {
//!     stream.write(&next_chunk).await.unwrap();
//! }
//! ```

pub(crate) mod codec;
mod dac;

pub use dac::*;

use embassy_hal_internal::Peripheral;

use crate::{interrupt, peripherals};

/// Audio sample rate.
///
/// Determines the AUDPRC strobe divider from a 48MHz XTAL clock source.
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
#[cfg_attr(feature = "defmt", derive(defmt::Format))]
pub enum SampleRate {
    Hz8000,
    Hz16000,
    Hz32000,
    Hz44100,
    Hz48000,
}

impl SampleRate {
    /// AUDPRC STB register `dac_div` value.
    ///
    /// From C SDK `audprc_clk_cfg_tb`: XTAL_48MHz / dac_div = sample_rate.
    pub(crate) fn dac_div(&self) -> u16 {
        match self {
            Self::Hz8000 => 6000,
            Self::Hz16000 => 3000,
            Self::Hz32000 => 1500,
            Self::Hz44100 => 1088,
            Self::Hz48000 => 1000,
        }
    }

    /// STB clock select: PLL (true) or XTAL (false).
    ///
    /// 44.1kHz uses PLL for better accuracy; others use XTAL.
    pub(crate) fn stb_clk_sel(&self) -> bool {
        matches!(self, Self::Hz44100)
    }

    /// Sample rate in Hz.
    pub fn hz(&self) -> u32 {
        match self {
            Self::Hz8000 => 8000,
            Self::Hz16000 => 16000,
            Self::Hz32000 => 32000,
            Self::Hz44100 => 44100,
            Self::Hz48000 => 48000,
        }
    }
}

/// Audio channel mode.
///
/// Determines how audio samples are packed in 32-bit FIFO entries.
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
#[cfg_attr(feature = "defmt", derive(defmt::Format))]
pub enum ChannelMode {
    /// Each FIFO entry = one 16-bit sample (low 16 bits).
    Mono,
    /// Each FIFO entry = packed stereo pair `[R:hi16 | L:lo16]`.
    Stereo,
}

/// DAC output configuration.
#[non_exhaustive]
#[derive(Clone, Copy, Debug)]
#[cfg_attr(feature = "defmt", derive(defmt::Format))]
pub struct DacConfig {
    /// Sample rate (default: 48kHz).
    pub sample_rate: SampleRate,
    /// Channel mode (default: Stereo).
    pub channel_mode: ChannelMode,
    /// DAC path coarse volume, 0-15 (default: 6).
    pub volume: u8,
}

impl Default for DacConfig {
    fn default() -> Self {
        Self {
            sample_rate: SampleRate::Hz48000,
            channel_mode: ChannelMode::Stereo,
            volume: 6,
        }
    }
}

/// Audio driver error.
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
#[cfg_attr(feature = "defmt", derive(defmt::Format))]
pub enum Error {
    /// DMA transfer error.
    Dma,
    /// FIFO overrun.
    Overrun,
}

// Instance trait for AUDPRC (singleton, needed for DMA trait system)
#[allow(private_interfaces)]
pub(crate) trait SealedInstance: crate::rcc::RccEnableReset {}

#[allow(private_bounds)]
pub trait Instance: Peripheral<P = Self> + SealedInstance + 'static + Send {
    #[doc(hidden)]
    type Interrupt: interrupt::typelevel::Interrupt;
}

impl SealedInstance for peripherals::AUDPRC {}

impl Instance for peripherals::AUDPRC {
    type Interrupt = crate::interrupt::typelevel::AUDPRC;
}

// DMA traits (implementations generated by build.rs from dma.yaml)
dma_trait!(TxCh0Dma, Instance);
dma_trait!(RxCh0Dma, Instance);
