use std::fs;
use std::path::Path;
use std::process::Command;

fn main() -> Result<(), Box<dyn std::error::Error>> {
    let out_dir = std::env::var("OUT_DIR")?;
    let out_dir = Path::new(&out_dir);

    let data_dir = Path::new("data").join("sf32lb52x");

    generate_rom_config(&data_dir, out_dir)?;

    Ok(())
}

// ── ROM config layout types ─────────────────────────────────────────────────

#[derive(serde::Deserialize)]
struct RomConfigLayout {
    bank: RomConfigBank,
}

#[derive(serde::Deserialize)]
struct RomConfigBank {
    #[allow(dead_code)]
    id: String,
    #[allow(dead_code)]
    name: String,
    #[allow(dead_code)]
    note: Option<String>,
    source: String,
    module: String,
    size_a3: u64,
    /// Full size (Letter Series).
    size: u64,
    magic: u64,
    #[serde(default)]
    regions: Vec<RomConfigRegion>,
}

#[derive(serde::Deserialize)]
struct RomConfigRegion {
    #[allow(dead_code)]
    name: String,
    offset: u64,
    size: u64,
    #[allow(dead_code)]
    color: Option<String>,
    note: String,
    source: String,
    #[serde(default)]
    exports: Vec<RomConfigExport>,
    /// Optional sub-module name for nested regions (e.g. "bt" for BtRomConfig).
    sub_module: Option<String>,
    /// Nested sub-regions (offsets relative to this region).
    #[serde(default)]
    regions: Vec<RomConfigRegion>,
    /// Bit position in the parent's `bit_valid` field (for validity bitmask generation).
    valid_bit: Option<u32>,
    /// Rust struct name to generate (e.g. "ActConfig").
    rust_struct: Option<String>,
    /// Visibility qualifier (e.g. "pub", "pub(crate)").
    rust_vis: Option<String>,
    /// Derive macros to apply (e.g. ["Debug", "Clone", "Copy"]).
    #[serde(default)]
    rust_derives: Vec<String>,
}

#[derive(serde::Deserialize)]
struct RomConfigExport {
    name: String,
}

// ── Code generation ─────────────────────────────────────────────────────────

fn generate_rom_config(
    data_dir: &Path,
    out_dir: &Path,
) -> Result<(), Box<dyn std::error::Error>> {
    let toml_path = data_dir.join("rom_config_layout.toml");
    println!("cargo:rerun-if-changed={}", toml_path.display());

    let content = fs::read_to_string(&toml_path)?;
    let layout: RomConfigLayout = toml::from_str(&content)?;

    let bank = &layout.bank;
    let mut out = String::from(
        "// Generated by build.rs from rom_config_layout.toml — do not edit.\n\n",
    );

    out.push_str(&format!(
        "/// ROM configuration block field offsets.\n\
         ///\n\
         /// SDK: `{}`.\n\
         #[allow(dead_code)]\n\
         pub mod {} {{\n",
        bank.source, bank.module,
    ));

    for region in &bank.regions {
        for exp in &region.exports {
            out.push_str(&format!(
                "    /// {} ({}B). Source: `{}`\n    pub const {}: usize = {};\n",
                region.note,
                region.size,
                region.source,
                exp.name,
                fmt_hex(region.offset),
            ));
        }

        // Generate nested sub-module if present.
        if let Some(ref sub_mod) = region.sub_module {
            if !region.regions.is_empty() {
                out.push_str(&format!(
                    "\n    /// {} sub-field offsets (relative to {}).\n    pub mod {} {{\n",
                    region.name,
                    region.exports.first().map(|e| e.name.as_str()).unwrap_or(&region.name),
                    sub_mod,
                ));
                for sub in &region.regions {
                    for exp in &sub.exports {
                        out.push_str(&format!(
                            "        /// {} ({}B). Source: `{}`\n        pub const {}: usize = {};\n",
                            sub.note,
                            sub.size,
                            sub.source,
                            exp.name,
                            fmt_hex(sub.offset),
                        ));
                    }
                }

                // Generate `valid` sub-module for bit_valid bitmask constants.
                let valid_fields: Vec<_> = region.regions.iter()
                    .filter_map(|sub| {
                        sub.valid_bit.map(|bit| {
                            let name = sub.exports.first()
                                .map(|e| e.name.as_str())
                                .unwrap_or(&sub.name);
                            (name.to_string(), bit)
                        })
                    })
                    .collect();
                if !valid_fields.is_empty() {
                    out.push_str(
                        "\n        /// `bit_valid` bitmask constants.\n\
                             ///\n\
                             /// Each constant marks the corresponding field as valid.\n\
                             /// SDK: `middleware/bluetooth/include/rom_config.h`\n\
                             pub mod valid {\n",
                    );
                    for (name, bit) in &valid_fields {
                        out.push_str(&format!(
                            "            pub const {name}: u32 = 1 << {bit};\n",
                        ));
                    }
                    out.push_str("        }\n");
                }

                // Generate #[repr(C)] struct if `rust_struct` is set.
                if let Some(ref struct_name) = region.rust_struct {
                    out.push_str(&generate_repr_c_struct(region, struct_name, 2));
                }

                out.push_str("    }\n");
            }
        }
    }

    out.push_str(&format!(
        "\n    /// Block size for A3 revision.\n    pub const SIZE_A3: usize = {};\n",
        fmt_hex(bank.size_a3),
    ));
    out.push_str(&format!(
        "    /// Block size for Letter Series.\n    pub const SIZE_LETTER: usize = {};\n",
        fmt_hex(bank.size),
    ));
    out.push_str(&format!(
        "    /// Magic value indicating valid ROM config.\n    pub const MAGIC_VALUE: u32 = {};\n",
        fmt_hex(bank.magic),
    ));

    out.push_str("}\n");

    let out_path = out_dir.join("rom_config_generated.rs");
    fs::write(&out_path, &out)?;
    rustfmt(&out_path);

    Ok(())
}

/// Generate a `#[repr(C)]` struct definition from a TOML region's sub-fields.
///
/// Fields are ordered by offset. Gaps between fields are filled with `_padN: [u8; M]`.
/// Field types are inferred from size: 1→u8, 2→u16, 4→u32.
/// `indent_level` controls the base indentation (number of 4-space levels).
fn generate_repr_c_struct(region: &RomConfigRegion, struct_name: &str, indent_level: usize) -> String {
    let indent = "    ".repeat(indent_level);
    let fi = "    ".repeat(indent_level + 1); // field indent

    let vis = region.rust_vis.as_deref().unwrap_or("");
    let vis_prefix = if vis.is_empty() {
        String::new()
    } else {
        format!("{vis} ")
    };

    let derives = if region.rust_derives.is_empty() {
        String::new()
    } else {
        format!("{indent}#[derive({})]\n", region.rust_derives.join(", "))
    };

    // Sort sub-fields by offset.
    let mut fields: Vec<&RomConfigRegion> = region.regions.iter().collect();
    fields.sort_by_key(|f| f.offset);

    let mut out = String::new();

    // Struct doc comment.
    out.push_str(&format!("\n{indent}/// {}\n{indent}///\n{indent}/// SDK: `{}`\n", region.note, region.source));
    out.push_str(&format!("{indent}#[repr(C)]\n"));
    out.push_str(&derives);
    out.push_str(&format!("{indent}{vis_prefix}struct {struct_name} {{\n"));

    let field_vis = if vis.is_empty() { "" } else { "pub " };
    let mut cursor: u64 = 0;
    let mut pad_idx: usize = 0;

    for field in &fields {
        // Insert padding if there's a gap.
        if field.offset > cursor {
            let gap = field.offset - cursor;
            out.push_str(&format!("{fi}{field_vis}_pad{pad_idx}: [u8; {gap}],\n"));
            pad_idx += 1;
        }

        let ty = size_to_type(field.size);
        out.push_str(&format!(
            "{fi}/// {} Source: `{}`\n{fi}{field_vis}{}: {ty},\n",
            field.note, field.source, field.name,
        ));
        cursor = field.offset + field.size;
    }

    // Trailing padding to match declared region size.
    if cursor < region.size {
        let gap = region.size - cursor;
        out.push_str(&format!("{fi}{field_vis}_pad{pad_idx}: [u8; {gap}],\n"));
    }

    out.push_str(&format!("{indent}}}\n"));
    out
}

/// Map a field size (in bytes) to a Rust primitive type.
fn size_to_type(size: u64) -> &'static str {
    match size {
        1 => "u8",
        2 => "u16",
        4 => "u32",
        8 => "u64",
        _ => panic!("unsupported field size: {size}"),
    }
}

/// Format an integer as a Rust hex literal with `_` separators.
fn fmt_hex(value: u64) -> String {
    if value == 0 {
        return "0".to_string();
    }
    let h = format!("{value:X}");
    let h = if h.len() > 4 {
        format!("{value:08X}")
    } else {
        h
    };
    let mut groups = Vec::new();
    let bytes = h.as_bytes();
    let mut i = bytes.len();
    while i > 0 {
        let start = i.saturating_sub(4);
        groups.push(&h[start..i]);
        i = start;
    }
    groups.reverse();
    format!("0x{}", groups.join("_"))
}

/// rustfmt a given path.
/// Failures are logged to stderr and ignored.
fn rustfmt(path: impl AsRef<Path>) {
    let path = path.as_ref();
    match Command::new("rustfmt").args([path]).output() {
        Err(e) => {
            eprintln!("failed to exec rustfmt {:?}: {:?}", path, e);
        }
        Ok(out) => {
            if !out.status.success() {
                eprintln!("rustfmt {:?} failed:", path);
                eprintln!("=== STDOUT:");
                eprintln!("{}", String::from_utf8_lossy(&out.stdout));
                eprintln!("=== STDERR:");
                eprintln!("{}", String::from_utf8_lossy(&out.stderr));
            }
        }
    }
}
